// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"fmt"
	"io"
	"strconv"
)

type BaseTask interface {
	IsBaseTask()
}

type Goal struct {
	Tasks          []*Task  `json:"tasks"`
	ConnectionWith []*Goal  `json:"connectionWith"`
	ID             *string  `json:"id"`
	Section        Section  `json:"section"`
	Name           string   `json:"name"`
	Description    string   `json:"description"`
	Estimation     *float64 `json:"estimation"`
	IsActive       *bool    `json:"isActive"`
	Timestamp      *string  `json:"timestamp"`
}

func (Goal) IsBaseTask()   {}
func (Goal) IsTaskOrGoal() {}

type InputGoal struct {
	ID             *string                 `json:"id"`
	Section        Section                 `json:"section"`
	Name           string                  `json:"name"`
	Description    string                  `json:"description"`
	Estimation     *float64                `json:"estimation"`
	IsActive       *bool                   `json:"isActive"`
	Timestamp      *string                 `json:"timestamp"`
	Tasks          []*InputTask            `json:"tasks"`
	ConnectionWith []*InputGoalDefinitions `json:"connectionWith"`
}

type InputGoalDefinitions struct {
	Name *string `json:"name"`
	ID   *string `json:"id"`
}

type InputTask struct {
	ID             *string                 `json:"id"`
	Section        Section                 `json:"section"`
	Name           string                  `json:"name"`
	Description    string                  `json:"description"`
	Estimation     *float64                `json:"estimation"`
	IsActive       *bool                   `json:"isActive"`
	Timestamp      *string                 `json:"timestamp"`
	SubTasks       []*InputTask            `json:"subTasks"`
	ConnectionWith []*InputGoalDefinitions `json:"connectionWith"`
}

type SearchArgs struct {
	Cursor string `json:"cursor"`
	Count  int    `json:"count"`
}

type Task struct {
	Parent         TaskOrGoal `json:"parent"`
	SubTasks       []*Task    `json:"subTasks"`
	ConnectionWith []*Goal    `json:"connectionWith"`
	ID             *string    `json:"id"`
	Section        Section    `json:"section"`
	Name           string     `json:"name"`
	Description    string     `json:"description"`
	Estimation     *float64   `json:"estimation"`
	IsActive       *bool      `json:"isActive"`
	Timestamp      *string    `json:"timestamp"`
}

func (Task) IsBaseTask()   {}
func (Task) IsTaskOrGoal() {}

type TaskOrGoal interface {
	IsTaskOrGoal()
}

type Section string

const (
	SectionProductivity Section = "PRODUCTIVITY"
	SectionEfficiency   Section = "EFFICIENCY"
	SectionTodo         Section = "TODO"
	SectionImprovement  Section = "IMPROVEMENT"
)

func (e Section) IsValid() bool {
	switch e {
	case SectionProductivity, SectionEfficiency, SectionTodo, SectionImprovement:
		return true
	}
	return false
}

func (e Section) String() string {
	return string(e)
}

func (e *Section) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Section(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Section", str)
	}
	return nil
}

func (e Section) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
