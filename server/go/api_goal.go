/*
 * Do-to
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"encoding/json"
	"fmt"
	"github.com/jmcvetta/neoism"
	"github.com/rusakov/doto/server/neover/neo"
	"net/http"
	"net/url"
	"path"
	"strings"
)

func GoalPost(w http.ResponseWriter, r *http.Request) {
	goal := Goal{}

	section, _ := url.Parse(r.URL.Path)
	ps := path.Base(section.Path)
	println(ps)

	e := json.NewDecoder(r.Body).Decode(&goal)
	if e != nil {
		http.Error(w, e.Error(), 500)
		return
	}

	var inode map[string]interface{}
	unmarsh, _ := json.Marshal(goal)
	er := json.Unmarshal(unmarsh, &inode)
	if er != nil {
		http.Error(w, e.Error(), 500)
	}

	for field, val := range inode {
		fmt.Println("KV Pair: ", field, " : ", val)
	}

	n, err := neo.Db.CreateNode(inode)
	if err != nil {
		http.Error(w, err.Error(), 500)
		return
	}
	n.AddLabel("GOAL")

	output, err := json.Marshal(goal)
	if err != nil {
		http.Error(w, err.Error(), 500)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("content-type", "application/json")
	w.Write(output)
}

func GoalsSection(w http.ResponseWriter, r *http.Request) {
	u, _ := url.Parse(r.URL.Path)
	queryPar := path.Base(u.Path)

	res0 := []struct {
		N neoism.Node // Column "n" gets automagically unmarshalled into field N
	}{}

	cq1 := neoism.CypherQuery{
		Statement:  `MATCH (n:GOAL) WHERE n.section = {section} RETURN n`,
		Parameters: neoism.Props{"section": queryPar},
		Result:     &res0,
	}
	err := neo.Db.Cypher(&cq1)

	output, err := json.Marshal(res0)
	if err != nil {
		http.Error(w, err.Error(), 500)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("content-type", "application/json")
	w.Write(output)
}

func GoalsSectionQuery(w http.ResponseWriter, r *http.Request) {
	sections := r.URL.Query()["sections"]

	res0 := []struct {
		N neoism.Node // unmarshalled into field N
	}{}

	if sections != nil {
		s := strings.Split(sections[0], ",")
		println("multi")
		for i, v := range s {
			println(i, v)
		}
		cq1 := neoism.CypherQuery{
			Statement:  `MATCH (n:GOAL) WHERE n.section IN {sections} RETURN n`,
			Parameters: neoism.Props{"sections": &s},
			Result:     &res0,
		}
		err := neo.Db.Cypher(&cq1)

		output, err := json.Marshal(res0)
		if err != nil {
			http.Error(w, err.Error(), 500)
			return
		}

		w.Write(output)
	} else{
		cq1 := neoism.CypherQuery{
			Statement: `MATCH (n:GOAL) RETURN n`,
			Result:    &res0,
		}
		err := neo.Db.Cypher(&cq1)

		output, err := json.Marshal(res0)
		if err != nil {
			http.Error(w, err.Error(), 500)
			return
		}

		w.Write(output)
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}
